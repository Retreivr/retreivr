# YouTube Archiver

A robust YouTube playlist archiver that downloads sequentially, embeds full metadata and cover art, and copies videos to your media library with a minimal SQLite history to avoid duplicates.

## Features
- Sequential downloads to avoid IP throttling, with resumable retries and multiple extractor profiles.
- Clean, human-readable filenames with optional templating and format conversion (webm/mp4/mkv).
- Embedded metadata (title, channel, upload date, description, tags, URL) plus thumbnail as cover art.
- Background copy to final storage; only marks a video complete after a successful copy.
- SQLite download log to skip already archived items; lock file to prevent overlapping runs.
- Optional Telegram notifications after each run.
- Optional Tkinter config editor (`config_gui.py`) that edits the config.json file.

## Requirements
- Python 3.10+
- ffmpeg (for muxing and metadata embedding)
- yt-dlp (installed via `pip install -r requirements.txt`)
- Deno or Node.js runtime (for yt-dlp EJS; auto-detected, or specify via `js_runtime` or env `YT_DLP_JS_RUNTIME`)
- Google Cloud project with YouTube Data API v3 enabled

## Installation
```bash
git clone https://github.com/yourname/youtube-archiver.git
cd youtube-archiver
python -m venv .venv
source .venv/bin/activate  # Windows: .venv\Scripts\activate
pip install -r requirements.txt
```

Install ffmpeg via your package manager (Homebrew `brew install ffmpeg`, Debian/Ubuntu `sudo apt-get install ffmpeg`, etc.).

## Create Google OAuth credentials
1. Go to https://console.cloud.google.com/ and create/select a project.
2. Enable the **YouTube Data API v3**.
3. In **APIs & Services > Credentials**, create **OAuth client ID** with application type **Desktop app**.
4. Download the JSON and save it inside the repo (e.g., `tokens/client_secret_family.json`). Keep it private.

Generate a token for each account using the headless helper:
```bash
python setup_oauth.py <account_name> tokens/client_secret_<account>.json tokens/token_<account>.json
```
The script will print an authorization URL; open it, approve access, paste the code, and the token JSON will be written.

## Configuration - Sample config.json
Create `config/config.json` (or copy `config/config_sample.json` and fill in). Example:
```json
{
  "poll_interval_minutes": 15,
  "accounts": {
    "family_tv": {
      "client_secret": "tokens/client_secret_family.json",
      "token": "tokens/token_family.json"
    }
  },
  "playlists": [
    {
      "playlist_id": "PLXXXXXXXXXXXXXXX",
      "folder": "/Media/Videos/YouTube-Downloads",
      "account": "family_tv",
      "remove_after_download": false
    }
  ],
  "yt_dlp_opts": {},
  "filename_template": "%(title)s - %(uploader)s - %(upload_date)s.%(ext)s",
  "final_format": "webm",
  "js_runtime": "deno:/usr/local/bin/deno",
  "telegram": {
    "bot_token": "",
    "chat_id": ""
  }
}
```

Key fields:
- `accounts`: map of account name to `client_secret` (from Google) and `token` (generated by `setup_oauth.py`).
- `playlists`: each entry needs `playlist_id`, `folder` destination, `account` key, and optional `remove_after_download` to delete from the playlist after archiving.
- `filename_template`: Python `%` template; available keys: `title`, `uploader`, `upload_date`, `ext`.
- `final_format`: set to `webm` (default), `mp4`, or `mkv` for a final container copy.
- `js_runtime`: optional override; format `deno:/path/to/deno` or `node:/path/to/node`. Otherwise auto-detected or taken from `YT_DLP_JS_RUNTIME`.
- `telegram`: optional bot credentials for run summaries.
- `yt_dlp_opts`: additional yt-dlp options merged into the downloader.

Tip: keep `tokens/` and `config/config.json` out of version control.
- Note: `yt-dlp.conf` is not used by `archiver.py` (options are set in code). You can delete or customize it for manual yt-dlp runs if you like.
- Download order: prefers WebM VP9/Opus at 1080p then 720p, then falls back to MP4 1080p/720p. `final_format` is a container copy only—if a download falls back to MP4, set `final_format` to `mp4` (or leave blank) to avoid container mismatch.

## Running the archiver
```bash
source .venv/bin/activate
# run as a non-root user (e.g., UID 1000) with a cooperative umask so files are 664/775
umask 0002
python archiver.py --config config/config.json
```
- Uses `temp_downloads/` for work files, then copies to your target folder.
- Writes logs to `logs/archiver.log` and download history to `database/db.sqlite`.
- Creates `/tmp/yt_archiver.lock` to prevent overlapping runs.

Schedule it with cron/systemd, e.g.:
```
*/30 * * * * umask 0002; sudo -u youruser /usr/bin/python /path/to/archiver.py --config /path/to/config/config.json >> /path/to/logs/cron.log 2>&1
```

## Optional GUI editor
Run `python config_gui.py`, pick your `config.json`, and edit playlists/Telegram/filename options. Accounts are displayed read-only; manage OAuth files on disk.

## Troubleshooting
- yt-dlp complaining about JavaScript engine: set `js_runtime` in the config or `export YT_DLP_JS_RUNTIME=deno:/usr/local/bin/deno`.
- Metadata/cover art requires `ffmpeg`; ensure it is on your PATH.

## License
MIT — see LICENSE.
